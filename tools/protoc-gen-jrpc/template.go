package main

import (
	"text/template"

	"github.com/jakewright/home-automation/libraries/go/protoparse"
)

var tmpl *template.Template

func init() {
	var err error
	tmpl, err = template.New("jrpc").Parse(templateText)
	if err != nil {
		panic(err)
	}
}

type method struct {
	Name       string
	InputType  string
	OutputType string
	HTTPMethod string
	Path       string
	URL        string
}

type data struct {
	PackageName string
	RouterName  string
	Imports     []*protoparse.Import
	Methods     []*method
}

const templateText = `// Code generated by protoc-gen-jrpc. DO NOT EDIT.

package {{ .PackageName }}

{{ if .Imports }}
	import (
		{{- range .Imports }}
			{{ .Alias }} "{{ .Path }}"
		{{- end }}
	)
{{ end }}

// {{ .RouterName }} wraps router.Router to provide a convenient way to set handlers
type {{ .RouterName }} struct {
	*router.Router
	{{- range .Methods }}
    	{{ .Name }} func(*{{ .InputType }}) (*{{ .OutputType }}, error)
	{{- end }}
}

// NewRouter returns a router that is ready to add handlers to
func NewRouter() *{{ .RouterName }} {
	rr := &{{ .RouterName }}{
		Router: router.New(),
	}

	{{ range .Methods }}
		rr.Router.Handle("{{ .HTTPMethod }}", "{{ .Path }}", func(w http.ResponseWriter, r *http.Request) {
			body := &{{ .InputType }}{}
			if err := request.Decode(r, body); err != nil {
				response.WriteJSON(w, err)
				return
			}

			if rr.{{ .Name }} == nil {
				slog.Panic("No handler exists for {{ .HTTPMethod }} {{ .URL }}")
			}

			rsp, err := rr.{{ .Name }}(body)
			if err != nil {
				slog.Error("Failed to handle request: %v", err)
				response.WriteJSON(w, err)
				return
			}

			response.WriteJSON(w, rsp)
		})
	{{ end }}

	return rr
}

{{ range .Methods }}
	// Do makes performs the request
	func (m *{{ .InputType }}) Do() (*{{ .OutputType }}, error) {
		req := &rpc.Request{
			Method: "{{ .HTTPMethod }}",
			URL: "{{ .URL }}",
			Body: m,
		}

		rsp := &{{ .OutputType }}{}
		_, err := rpc.Do(req, rsp)
		return rsp, err
	}
{{ end -}}

`
