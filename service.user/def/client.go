// Code generated by jrpc. DO NOT EDIT.

package userdef

import (
	context "context"
	"testing"

	taxi "github.com/jakewright/home-automation/libraries/go/taxi"
)

// UserService is the public interface of this service
type UserService interface {
	GetUser(ctx context.Context, body *GetUserRequest) *GetUserFuture
	ListUsers(ctx context.Context, body *ListUsersRequest) *ListUsersFuture
}

// GetUserFuture represents an in-flight GetUser request
type GetUserFuture struct {
	done <-chan struct{}
	rsp  *GetUserResponse
	err  error
}

// Wait blocks until the response is ready
func (f *GetUserFuture) Wait() (*GetUserResponse, error) {
	<-f.done
	return f.rsp, f.err
}

// ListUsersFuture represents an in-flight ListUsers request
type ListUsersFuture struct {
	done <-chan struct{}
	rsp  *ListUsersResponse
	err  error
}

// Wait blocks until the response is ready
func (f *ListUsersFuture) Wait() (*ListUsersResponse, error) {
	<-f.done
	return f.rsp, f.err
}

// UserClient makes requests to this service
type UserClient struct {
	dispatcher taxi.Dispatcher
}

// Compile-time assertion that the client implements the interface
var _ UserService = (*UserClient)(nil)

// NewUserClient returns a new client
func NewUserClient(d taxi.Dispatcher) *UserClient {
	return &UserClient{
		dispatcher: d,
	}
}

// GetUser dispatches an RPC to the service
func (c *UserClient) GetUser(ctx context.Context, body *GetUserRequest) *GetUserFuture {
	taxiFtr := c.dispatcher.Dispatch(ctx, &taxi.RPC{
		Method: "GET",
		URL:    "service.user/user",
		Body:   body,
	})

	done := make(chan struct{})
	ftr := &GetUserFuture{
		done: done,
	}

	go func() {
		defer close(done)
		ftr.err = taxiFtr.DecodeResponse(&ftr.rsp)
	}()

	return ftr
}

// ListUsers dispatches an RPC to the service
func (c *UserClient) ListUsers(ctx context.Context, body *ListUsersRequest) *ListUsersFuture {
	taxiFtr := c.dispatcher.Dispatch(ctx, &taxi.RPC{
		Method: "GET",
		URL:    "service.user/users",
		Body:   body,
	})

	done := make(chan struct{})
	ftr := &ListUsersFuture{
		done: done,
	}

	go func() {
		defer close(done)
		ftr.err = taxiFtr.DecodeResponse(&ftr.rsp)
	}()

	return ftr
}

// MockUserClient can be used in tests
type MockUserClient struct {
	dispatcher *taxi.MockClient
}

// Compile-time assertion that the mock client implements the interface
var _ UserService = (*MockUserClient)(nil)

// NewMockUserClient returns a new mock client
func NewMockUserClient(ctx context.Context, t *testing.T) *MockUserClient {
	f := taxi.NewTestFixture(t)

	return &MockUserClient{
		dispatcher: &taxi.MockClient{Handler: f},
	}
}

// GetUser dispatches an RPC to the mock client
func (c *MockUserClient) GetUser(ctx context.Context, body *GetUserRequest) *GetUserFuture {
	taxiFtr := c.dispatcher.Dispatch(ctx, &taxi.RPC{
		Method: "GET",
		URL:    "service.user/user",
		Body:   body,
	})

	done := make(chan struct{})
	ftr := &GetUserFuture{
		done: done,
	}

	go func() {
		defer close(done)
		ftr.err = taxiFtr.DecodeResponse(&ftr.rsp)
	}()

	return ftr
}

// ListUsers dispatches an RPC to the mock client
func (c *MockUserClient) ListUsers(ctx context.Context, body *ListUsersRequest) *ListUsersFuture {
	taxiFtr := c.dispatcher.Dispatch(ctx, &taxi.RPC{
		Method: "GET",
		URL:    "service.user/users",
		Body:   body,
	})

	done := make(chan struct{})
	ftr := &ListUsersFuture{
		done: done,
	}

	go func() {
		defer close(done)
		ftr.err = taxiFtr.DecodeResponse(&ftr.rsp)
	}()

	return ftr
}
